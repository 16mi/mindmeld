

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Anatomy of a Deep-Domain Conversational AI System &mdash; Workbench 1.0.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Workbench 1.0.0 documentation" href="index.html"/>
        <link rel="next" title="Getting Started" href="getting_started.html"/>
        <link rel="prev" title="Welcome to the MindMeld Workbench" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Workbench
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Learn</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Anatomy of a Deep-Domain Conversational AI System</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#natural-language-parser">Natural Language Parser</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#domain-classifier">Domain Classifier</a></li>
<li class="toctree-l3"><a class="reference internal" href="#intent-classifier">Intent Classifier</a></li>
<li class="toctree-l3"><a class="reference internal" href="#entity-recognizer">Entity Recognizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#entity-resolver">Entity Resolver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#role-classifier">Role Classifier</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semantic-parsing">Semantic Parsing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dialogue-manager">Dialogue Manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="#question-answerer">Question Answerer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#natural-language-generator">Natural Language Generator</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Build</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="training_data.html">Training Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="kb.html">Building The Knowledge Base</a></li>
<li class="toctree-l1"><a class="reference internal" href="entity_map.html">Defining The Entity Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="domain_classification.html">Building the Domain Classifier</a></li>
<li class="toctree-l1"><a class="reference internal" href="intent_classification.html">Building the Intent Classifier</a></li>
<li class="toctree-l1"><a class="reference internal" href="entity_recognition.html">Building the Entity Recognizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="role_classification.html">Building The Role Classifier</a></li>
<li class="toctree-l1"><a class="reference internal" href="entity_resolution.html">Building the Entity Resolver</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantic_parsing.html">Building the Semantic Parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="dialogue_manager.html">Building the Dialogue Manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="question_answering.html">Building the Question Answerer</a></li>
<li class="toctree-l1"><a class="reference internal" href="nlg.html">Building the NLG</a></li>
</ul>
<p class="caption"><span class="caption-text">Deploy</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="deployment.html">Deploying Conversational Apps</a></li>
</ul>
<p class="caption"><span class="caption-text">Notebook</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="hello-world.html">Hello, World!</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Workbench</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Anatomy of a Deep-Domain Conversational AI System</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/anatomy.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

/* nice headers on first paragraph of info/warning boxes */
.admonition .first {
    margin: -12px;
    padding: 6px 12px;
    margin-bottom: 12px;
    color: #fff;
    line-height: 1;
    display: block;
}
.admonition.warning .first {
    background: #f0b37e;
}
.admonition.note .first {
    background: #6ab0de;
}
.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}
</style>
<div class="section" id="anatomy-of-a-deep-domain-conversational-ai-system">
<h1>Anatomy of a Deep-Domain Conversational AI System<a class="headerlink" href="#anatomy-of-a-deep-domain-conversational-ai-system" title="Permalink to this headline">¶</a></h1>
<p>The MindMeld deep-domain conversational AI platform consists of several state-of-the-art Natural Language Processing modules, that work together to provide an intelligent end-to-end conversational experience.</p>
<a class="reference external image-reference" href="_images/architecture.png"><img alt="_images/architecture.png" src="_images/architecture.png" /></a>
<p>This chapter will introduce you to the each of the modules in the MindMeld toolkit.</p>
<div class="section" id="natural-language-parser">
<h2>Natural Language Parser<a class="headerlink" href="#natural-language-parser" title="Permalink to this headline">¶</a></h2>
<p>The Natural Language Parser is tasked with comprehending the user&#8217;s natural language input. This involves processing the input text using a combination of techniques such as pattern matching, text classification, information extraction and parsing. The end goal is to produce an actionable semantic representation that can be used to satisfy the dialogue task.</p>
<p>E.g. If the user says &#8220;A medium soy milk latte with hazelnut and caramel syrups and two slices of lemon bread.&#8221;, the parser would produce:</p>
<a class="reference external image-reference" href="_images/parser.png"><img alt="_images/parser.png" src="_images/parser.png" /></a>
<p>The MindMeld Parser analyzes the input using a hierarchy of classification models, with each model assisting the next tier of models by narrowing the problem scope, or in other words, by successively narrowing down the &#8220;search space&#8221;.</p>
<a class="reference external image-reference" href="_images/classifier_hierarchy.png"><img alt="_images/classifier_hierarchy.png" src="_images/classifier_hierarchy.png" style="width: 555.0px; height: 655.5px;" /></a>
<p>We next take a look at each of the classifiers within the MindMeld Parser one by one.</p>
<div class="section" id="domain-classifier">
<h3>Domain Classifier<a class="headerlink" href="#domain-classifier" title="Permalink to this headline">¶</a></h3>
<p>The first level of categorization is done by the Domain Classifier, which classifies the input into one of the predetermined set of domains that can be handled by the conversational system. A &#8220;domain&#8221; can be thought of as a broad category covering multiple related user intents. Generally, each domain would have its own specialized vocabulary or terminology, that sets it apart from other domains.</p>
<p>For instance, a conversational system built for smart home automation would be expected to handle several distinct tasks such as setting the temperature on the thermostat, toggling the light fixtures in different rooms, locking/unclocking different doors and controlling multimedia devices around the home. The vocabulary for changing the settings on the thermostat is very specific and completely different from interacting with the television. You could therefore consider modeling them under separate domains - a &#8220;thermostat&#8221; domain for handling all interactions related to the thermostat and similarly a &#8220;multimedia&#8221; domain.</p>
<p>On the other hand, you can also have applications where you just have one de facto domain. This is usually the case if all the tasks that your system can handle are conceptually related and share the same vocabulary. For instance, a food ordering app could potentially handle multiple intents like searching for restaurants, getting more information about a particular restaurant, placing an order, etc. But the vocabulary used for accomplishing any of these tasks would be shared to a large extent.</p>
<p>The number of domains thus depends on the scope of your application. Personal assistants like Siri, Cortana, Google Assistant and Alexa are capable of handling several different domains.</p>
<p>The Domain Classifier uses a machine-learned text classification model trained by providing many examples of user queries along with their true domain labels. At runtime, the Classifier analyzes the user input and assigns it a domain, based on the most likely one predicted by the trained model.</p>
<p>See the chapter on <a class="reference internal" href="training_data.html"><span class="doc">Training data</span></a> for a discussion on generating the labelled data for training. In the <a class="reference internal" href="domain_classification.html"><span class="doc">Building The Domain Classifier</span></a> chapter, we will take a closer look at training and evaluating the domain classification model.</p>
</div>
<div class="section" id="intent-classifier">
<h3>Intent Classifier<a class="headerlink" href="#intent-classifier" title="Permalink to this headline">¶</a></h3>
<p>Once the domain for the user input has been determined, the next level of categorization is provided by the Intent Classifier. An &#8220;intent&#8221; refers to a very specific kind of informational or transactional user need. The user may want to book a flight, search for movies from a catalog, know about the weather conditions somewhere or set the temperature on their home thermostat. Each of these is an example of a user intent.</p>
<p>A domain can, and usually has multiple intents. For instance, the de facto &#8220;food&#8221; domain in a food ordering app would at least contain intents such as:</p>
<p>search_restaurant: Searching for restaurants matching a particular set of criteria
get_restaurant_info: Get general information about a selected restaurant like hours, cuisine, price range, etc.
list_dishes: List all the dishes available at a selected restaurant, optionally filtered by certain criteria
place_order: Place an order for pick up or delivery</p>
<p>By convention, we use verbs to name our intents as they inherently refer to an action that needs to be taken.</p>
<p>The Intent Classifier, similar to the Domain Classifier uses a machine-learned text classification model that is trained using labelled training data. We train one intent classification model per domain and the Classifier at runtime chooses the appropriate model, based on the predicted domain for the input query. The output of the Intent Classifier is an intent label which allows us to identify the exact task that the user is trying to solve.</p>
<p>We describe how to build intent classification models in <a class="reference internal" href="intent_classification.html"><span class="doc">Building the Intent Classifier</span></a>.</p>
</div>
<div class="section" id="entity-recognizer">
<h3>Entity Recognizer<a class="headerlink" href="#entity-recognizer" title="Permalink to this headline">¶</a></h3>
<p>After the user intent has been established by the Intent Classifier, the next step is to identify all the entities relevant to satisfying the user intent. An &#8220;entity&#8221; is any important word or phrase that provides further information about the user&#8217;s end goal. For instance, if the user intent was to search for a movie, the relevant entities would be things like movie titles, genre, cast names, etc. If the intent was to update the thermostat, the entity would be the numerical value of the temperature to set the thermostat to.</p>
<p>For programmers, a good analogy is to think of intents as functions and entities as the arguments you pass into the function call. E.g. set_thermostat(temperature = 70), get_weather_info(city = &#8216;San Francisco&#8217;), find_movies(release_year = &#8216;2016&#8217;, actor = &#8216;Tom Hanks&#8217;, genre = &#8216;Drama&#8217;).</p>
<p>The Entity Recognizer&#8217;s job is to analyze the user input and extract all the entities relevant to the current intent. In NLP literature, this problem is commonly referred to as <a class="reference external" href="https://en.wikipedia.org/wiki/Named-entity_recognition">Named Entity Recognition</a>.</p>
<p>The problem essentially consists of two parts:</p>
<ol class="arabic simple">
<li>Detect which spans of words within the input text correspond to entities of interest</li>
<li>Classify those detected text spans into a pre-determined set of entity types</li>
</ol>
<p>The Entity Recognizer uses a machine-learned sequence labeling model to look at each word in the input query sequentially and assign a label to it. It is trained using labeled training data where queries are annotated to mark entity spans along with their corresponding entity types. We train a separate entity recognition model for each user intent since the types of entities required to satisfy the end goal vary from intent to intent. We will get into the details of build entity recognition models in <a class="reference internal" href="entity_recognition.html"><span class="doc">Building the Entity Recognizer</span></a>.</p>
<p>At runtime, the Entity Recognizer loads up and uses the appropriate model, based on the predicted intent for the query. Once this step is done and we&#8217;ve extracted the relevant entities, we finally have all the raw ingredients required to make sense out of the user input. It&#8217;s now a question of putting those together to build a semantic representation that encapsulates all the information necessary to execute the user&#8217;s intended action.</p>
</div>
<div class="section" id="entity-resolver">
<h3>Entity Resolver<a class="headerlink" href="#entity-resolver" title="Permalink to this headline">¶</a></h3>
<p>The Entity Resolver transforms the entity spans extracted by the Entity Recognizer into canonical forms that can be looked up in a catalog or a knowledge base. For instance, the extracted entity &#8220;lemon bread&#8221; may get resolved to &#8220;Iced Lemon Pound Cake&#8221;, &#8220;SF&#8221; may get resolved to &#8220;San Francisco&#8221; and so on. This problem of entity resolution is also referred to as <a class="reference external" href="https://en.wikipedia.org/wiki/Entity_linking">Entity Linking</a> in NLP literature.</p>
<p>The MindMeld Entity Resolver uses a resource called an Entity Map to transform extracted entities into their desired normalized forms. The chapters on <a class="reference internal" href="entity_map.html"><span class="doc">Defining the Entity Map</span></a> and <a class="reference internal" href="entity_resolution.html"><span class="doc">Building the Entity Resolver</span></a> provide more details on the entity resolution step.</p>
</div>
<div class="section" id="role-classifier">
<h3>Role Classifier<a class="headerlink" href="#role-classifier" title="Permalink to this headline">¶</a></h3>
<p>Role Classification a.k.a Semantic Role Labeling (SRL) is the task of identifying predicates and predicate arguments. A <strong>semantic role</strong> in language is the relationship that a syntactic constituent has with a predicate. In Conversational NLU, a <strong>&#8220;role&#8221;</strong> represents the semantic theme a given entity can take. It can also be used to define how a named entity should be used for fulfilling a query intent. For example, in the query &#8220;Play Black Sabbath by Black Sabbath&#8221;, the title entity &#8220;Black Sabbath&#8221; has different semantic themes - the first referring to the song, and the second referring to the artist.</p>
<p>Treating Named Entity Recognition (NER) and Semantic Role Labeling (SRL) as separate tasks has a few advantages -</p>
<ul class="simple">
<li>NER models are hurt by splitting examples across fairly similar categories. Grouping facets with significantly overlapping entities and similar surrounding natural language will lead to better parsing and let us use more powerful models.</li>
<li>Joint NER &amp; SRL needs global dependencies, but fast &amp; good NER models only do local. NER models (MEMM, CRF) quickly become intractable with long-distance dependencies. Separating NER from SRL let us use local dependencies for NER and long-distance dependencies in SRL.</li>
<li>Role labeling might be a multi-label problem. With multi-label roles, we can use the same entity to query multiple fields.</li>
</ul>
</div>
<div class="section" id="semantic-parsing">
<h3>Semantic Parsing<a class="headerlink" href="#semantic-parsing" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="dialogue-manager">
<h2>Dialogue Manager<a class="headerlink" href="#dialogue-manager" title="Permalink to this headline">¶</a></h2>
<p>The Dialogue Manager is responsible for directing the flow of the conversation. In contrast to other parts of the system that are stateless, the Dialogue Manager is stateful and maintains information about each state or step in the dialogue flow. It is therefore able to use historical context from previous conversation turns to move the dialogue along towards the end goal of satisfying the user&#8217;s intent.</p>
</div>
<div class="section" id="question-answerer">
<h2>Question Answerer<a class="headerlink" href="#question-answerer" title="Permalink to this headline">¶</a></h2>
<p>Broadly speaking, Question Answering is the task of retrieving relevant results from a Knowledge Base in response to a natural language question. In Deep-Domain Conversational AI, often we have a large content catalog that is imported into a Knowledge Base. The Question Answerer uses the structured output of the Language Parser to first construct a database query. The query is then executed on the Knowledge Base to retrieve a wide net of candidate answers to the query. These candidate answers are scored and ranked, and the top ranked results are returned as the most relevant documents to the natural language query.</p>
</div>
<div class="section" id="natural-language-generator">
<h2>Natural Language Generator<a class="headerlink" href="#natural-language-generator" title="Permalink to this headline">¶</a></h2>
<p>The Natural Language Generator (NLG) component frames the natural language response to be output to the user. It receives information about how the user&#8217;s intent has been processed and uses that in conjunction with a set of pre-defined templates to construct a fluent natural language text response. We will go into further details in <a class="reference internal" href="nlg.html"><span class="doc">Building the NLG</span></a> chapter.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="getting_started.html" class="btn btn-neutral float-right" title="Getting Started" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Welcome to the MindMeld Workbench" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, MindMeld Inc..

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>